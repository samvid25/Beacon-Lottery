# Beacon Lottery

This is a simple Ethereum smart contract based lottery written in Solidity. The contract randomly picks a winner from the participating users, and rewards the winner with some Ether. The source of randomness for determining the winner is a [randomness beacon](http://www.copenhagen-interpretation.com/home/cryptography/cryptographic-beacons) based on the [Sloth protocol](https://eprint.iacr.org/2015/366).

The working of the lottery is explained in the following sections:

## Lottery

The participants have to pay the contract a certain amount (by invoking `bet()`) to participate in the lottery. 
The contract owner calls `draw()` to determine the winner after a suitable number of users have placed their bets. A fraction of the total amount that was paid to the contract by the participants is paid to the winner of that round of the lottery. The rest is paid to the contract owner as earnings.

The contract obtains a random value from the beacon using an [oracle](www.oraclize.it). This value is used to randomly pick a winner from the participating users.

## Sloth Verification

The contract also performs verification (on request by a user) of the proof given by the beacon as per the verification algorithm given [here](https://github.com/randomchain/pysloth/blob/3ed53be7cb4da03aa83b4799729151454aa934a1/sloth.c#L200).

Sloth verification is performed using repeated modular squaring. The `bigModExp` precompile is used to perform this operation.

The following assumptions are made about the 'proof' given by the beacon:
- The proof contains `witness`, `seed`, `iter_exp` and `prime`.
    - The hash of the `witness` is the random value generated by the beacon.
    - The values of `seed` and `prime` are assumed to be computed by the beacon itself according to the algorithm [here](https://github.com/randomchain/pysloth/blob/3ed53be7cb4da03aa83b4799729151454aa934a1/sloth.c#L99) from the `input_string` which here is the root of merkle tree of inputs committed by the users.
    - `iter_exp` is the value: 2<sup>iterations</sup>. Squaring a value `iterations` times is the same as raising it to the exponent 2<sup>iterations</sup>. Pre-computing this value by the beacon allows for directly making use of the `bigModExp` precompile.
- The above parameters are encoded as strings (of their values in base-10) separated by hiphens for easy parsing in the smart contract.

A user who wants to verify the proof given by the beacon first invokes `fetch_proof()`, which obtains the proof from the beacon using the oracle, followed by `verify()` which performs the verification.

## Gas Values for Modular Exponentation

| Size of Witness (bits) | Size of Prime Modulus (bits) | Iterations | Gas       |
|------------------------|------------------------------|------------|-----------|
| 512                    | 512                          | 1024       | 159,129   |
| 1024                   | 1024                         | 1024       | 517,171   |
| 512                    | 512                          | 2048       | 368,844   |
| 1024                   | 1024                         | 2048       | 1,198,745 |

These values are obtained using the gas calculation formula given [here](https://eips.ethereum.org/EIPS/eip-198).
